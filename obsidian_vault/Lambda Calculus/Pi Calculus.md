Позволяет описывать конкурентные вычисления.

В пи исчислении существуют следующие конструкции:
1. Переменная `x`, `y` и тд. 
2.  "Канал" - `ch x -> body`. Определяет канал связи между двумя паралельными процессами, где один процесс есть получателем данных, а второй отправителем.
3. "Получение данных" - `x[y] -> body`. Ожидает данных из канала `x`, которые отправит продюсер и выполняет `body` с данными которые пришли.
4. "Отправка данных" - `x(y) rest`. Ждет пока получатель примет данные через канал `x`, и потом выполнить `rest`.
5. "Одновременное выполнение" - `x | y`. Выполняет `х` и `у` "одновременно".
6. "Нулевой процесс" - `0`. Процесс который уже закончился.

Так же из семантики вытекают следующие тождества:
* `x | y === y | x` - комутативность
* `(x | y) | z === x | (y | z)` - асоциативность
* `ch x -> (y | z) === (ch x -> y) | z` если `x` не используется в `z`
* `x | 0 === x`

## Редукция
Выражения можно упростить следуя следующим правилам:
* `ch x -> x[y] -> A | x(z) B => ch x -> A[y=z] | B` 
* Если `A => B` то и `A | C => B | C`
* Если `A => B` то и `ch x -> A => ch x -> B`
* Если `A => B`, `A === A'`, `B === B'` то и `A' => B'`

Можно сказать данное исчисление моделирует паралельные системы как набор потоков, которые передают друг другу данные пользуясь некоторым каналом передачи данных. 

Можно сделать гибрид лямбда исчисления и пи исчисления используя такие конструкции:
1. Переменная `x`, `y` и тд. 
2. "Абстракция", или функция/лямбда `fn x -> body`. Функции всегда объявляют одну переменную, которую можно использовать в теле функции. Тело функции распространяется максимально вправо, и ограничено лишь круглыми скобками. 
3. "Применение абстракции" или вызов функции, обозначаются двумя переменными подряд `x y`. Вызов функций лево-асоциативный, что значит `x y z = (x y) z` 
4.  "Канал" - `ch`. "Создает" уникальный канал для передачи данных между двумя паралельными процессами.
5. "Получение данных" - `x.receive fn y -> body`. Ожидает данных из канала `x`, которые отправит продюсер и вызивает переданную лямбду с полученными данными.
6. "Отправка данных" - `x.send y rest`. Ждет пока получатель примет данные через канал `x`, и вернет `rest`.
7. "Одновременное выполнение" - `x | y`. Выполняет `х` и `у` "одновременно".
6. "Нулевой процесс" - `void`. Процесс который уже закончился. Так же можно интерпретировтаь как значение которое нельзя использовать как функцию или аргумент.

Правила редукции тогда таковы:
1. `(fn x -> A) y => A[x=y]`
2. `fn x -> f x => f`
3. `... | (сh#n.send A B) | (сh#n.receive fn x -> C) => ... | B | C[x=A]`
4. `A | void => A`
5. `A | B => A | C` если `B => C`
6. `A (B | C) => (A B) | (A C)`
7.  `(A | B) C => (A C) | (B C)`
8.  `(fn x -> A) ch => A[x=ch#n]`, где `n` это порядковый номер появления канала в изначальном выражении
9.  `fn x -> (A | B) => A | fn x -> B` если `x` не используется в `A`

Примеры таких выражений и их редукций:
1. `(fn x -> (x.receive fn y -> y 2) | (x.send (fn z -> z + 1) 0)) ch`
	`(ch#0.receive fn y -> y 2) | (ch#0.send (fn z -> z + 1) 0)`
	`((fn z -> z + 1) 2) | (0)`
	`(fn z -> z + 1) 2)`
	`2 + 1`
	`3`
1. `(fn x -> (x.receive fn y -> x.send (y 2) ((y 3) * 2)) | (x.send (fn z -> z + 1) (x.receive fn x -> x * 2))) ch`
	`(ch#0.receive fn y -> ch#0.send (y 2) ((y 3) * 4)) | (ch#0.send (fn z -> z + 1) (ch#0.receive fn x -> x * 2))`
	`ch#0.send ((fn z -> z + 1) 2) (((fn z -> z + 1) 3) * 4) | ch#0.receive fn x -> x * 2`
	`(((fn z -> z + 1) 3) * 4) | ((fn z -> z + 1) 2) * 2`
	`(3 + 1) * 4 | (2 + 1) * 2`
	`4 * 4 | 3 * 2`
	`16 | 6`
3. `(fn w -> w * w) ((fn x -> (x.receive fn y -> x.send (y 2) ((y 3) * 2)) | (x.send (fn z -> z + 1) (x.receive fn x -> x * 2))) ch)`
	`(fn w -> w * w) (16 | 6)`
	`((fn w -> w * w) 16) | ((fn w -> w * w) 6)`
	`16 * 16 | 6 * 6`
	`256 | 36`

В такой формулировке вычисление выражений является недетерменированным процессом, что усложняет анализ.
Может получится так что надо выбирать между множеством получателей и отправителей, и так как все процессы равноправные, то этот выбор случаен, а значит и вся программа недетерменировання
Что бы избежать такой ситуации можно поставить ограничение - конец канала может иметь лишь один процес-владельца. В этом случае легко отследить кто получит, а кто отправит данные, и вычисление такого выражения становится детерменированым.
Альтернативный вариант внести детерменизм - определить процедуру выбора пары отправитель-получатель. Но тогда это может нарушить поедположение "равноправия" между процессами.
Иногда этот недетерменизм можно нигилировать сбором через комутативные операции, у которых результат не зависит от порядка значений
Например сумма значений все процессов всегда одна и та же, независимо от того кто когда закончил, зависит только от их отдельных значений.

Редукции между паралельными частями могут выполняться в любом порядке.
На самом деле такое поведение исходит из асоциативности паралельных процессов, тк иначе мы должны выбирать когда и какой поток получит\отправит данные, а какой нет, что может привести к разным результатам.
Таким образом комуникации между потоками являются точками синхронизации, тк перед тем что бы мы могли продолжить упрощать то что будет дальше, нам нужно дождаться что бы процессы или получили или отправили данные через канал.
При этом правила 5, 6 по сути являются следствиями дистрибутивности для операций вызова функции и паралельных вычислений.
Получается что для этой пары операций работают все законы знакомые с арифметики: дистрибутивность, комутативность, асоциативность.
Мы знаем что существует left identity `fn x -> x` для операции вызова, но несуществует правой единицы, увы.

Данный механизм может позволить например реализовать класический async\await без разукрашивания функций, как это в JS или Rust:

Пример работы такого асинк авейта:
```
{
  f = async fn x -> x + 1
  g = fn x -> x * 2

  x = f 2
  y = async g 3
  z = 3 + 1

  z + await y + await x
}
=> 
{
  f = fn x -> x + 1
  g = fn x -> x * 2

  | ch#0.send (f 2) void 
  | ch#0.receive fn x -> {
    y = async g 3
    z = 3 + 1

    z + await y + x
  }
}
=> 
{
  f = fn x -> x + 1
  g = fn x -> x * 2
  
  | ch#0.send (f 2) void 
  | ch#0.receive fn x -> 
    | ch#1.send (g 3) void 
    | ch#1.receive fn y -> {
      z = 3 + 1
      z + y + x
    }
}
=> 
{
  f = async fn x -> x + 1
  g = fn x -> x * 2
  
  | ch#0.send (f 2) void 
  | ch#1.send (g 3) void 
  | ch#0.receive fn x -> 
    | ch#1.receive fn y -> {
      z = 3 + 1
      z + y + x
    }
}
```

```
{
  f = async fn x -> x + 1
  x = f 2
  y = 3 + 1
  z = async fn w -> w * await x

  y + await (z 2)
}
```

Корутины:
```
{
  x := fn -> {
    yield 1;
    y := yield 2;
    y * 2
  }
  a := x()
  b := x()
  c := x 3
  a + b * c
}
=>
{
  ch#0.send ()
  a := ch#0.receive
  ch#0.send ()
  b := ch#0.receive
  ch#0.send 3
  c := ch#0.receive
  a + b * c
} | {
  ch#0.receive
  ch#0.send 1
  ch#0.receive
  ch#0.send 2
  y := ch#0.receive
  ch#0.send y * 2
} 
=>
{
  a := ch#0.receive
  ch#0.send ()
  b := ch#0.receive
  ch#0.send 3
  c := ch#0.receive
  a + b * c
} | {
  ()
  ch#0.send 1
  ch#0.receive
  ch#0.send 2
  y := ch#0.receive
  ch#0.send y * 2
} 
=>
{
  a := 1
  ch#0.send ()
  b := ch#0.receive
  ch#0.send 3
  c := ch#0.receive
  a + b * c
} | {
  ch#0.receive
  ch#0.send 2
  y := ch#0.receive
  ch#0.send y * 2
} 
=>
{
  a := 1
  b := ch#0.receive
  ch#0.send 3
  c := ch#0.receive
  a + b * c
} | {
  ()
  ch#0.send 2
  y := ch#0.receive
  ch#0.send y * 2
} 
=>
{
  a := 1
  b := 2
  ch#0.send 3
  c := ch#0.receive
  a + b * c
} | {
  y := ch#0.receive
  ch#0.send y * 2
} 
=>
{
  a := 1
  b := 2
  c := ch#0.receive
  a + b * c
} | {
  y := 3
  ch#0.send y * 2
} 
=>
{
  a := 1
  b := 2
  c := ch#0.receive
  a + b * c
} | {
  ch#0.send 3 * 2
}
=>
{
  a := 1
  b := 2
  c := 3 * 2
  a + b * c
} | {} 
=>
{
  a := 1
  b := 2
  c := 3 * 2
  a + b * c
}
```

Функции:
```
{
  x := fn x -> x * 2
  2 * x 5
}
=>
{
  ch#0.send 5
  2 * ch#0.receive
} | {
  x := ch#0.receive
  ch#0.send x * 2
}
=>
{
  2 * ch#0.receive
} | {
  x := 5
  ch#0.send x * 2
}
=>
{
  2 * ch#0.receive
} | {
  ch#0.send 5 * 2
}
=>
{
  2 * 5 * 2
} | {}
=>
{ 10 * 5 }
```

Оператор `|` достаточно удобен в такой интерпретации - позволяет нативно описывать подобие множеств (set) или случаи когда может быть несколько вариантов значений, как в юнионе типов.
  
[Pi-calculus](https://en.wikipedia.org/wiki/%CE%A0-calculus)