Позволяет описывать паралельные вычисления.

Дополнительно к ним создаются следующие конструкции:
1. Переменная `x`, `y` и тд. 
2.  "Канал" - `ch x -> body`. Определяет канал связи между двумя паралельными процессами, где один процесс есть получателем данных, а второй отправителем.
3. "Получение данных" - `x[y] -> body`. Ожидает данных из канала `x`, которые отправит продюсер и выполняет `body` с данными которые пришли.
4. "Отправка данных" - `[y -> x] rest`. Ждет пока получатель примет данные через канал `x`, и потом выполнить `rest`.
5. "Одновременное выполнение" - `x | y`. Выполняет `х` и `у` "одновременно".
6. "Нулевой процесс" - `0`. Процесс который уже закончился.

Так же из семантики вытекают следующие аксиомы:
* `x | y === y | x`
* `(x | y) | z === x | (y | z)` - асоциативность паралельных процессов
* `ch x -> (y | z) === (ch x -> y) | z` если `x` не используется в `z`
* `x | 0 === x`

## Редукция
Выражения можно упростить следуя следующим правилам:
* `ch x -> [x -> y] A | [z -> x] B => ch x -> A[y=z] | B` 
* Если `A => B` то и `A | C => B | C`
* Если `A => B` то и `ch x -> A => ch x -> B`
* Если `A => B`, `A === A'`, `B === B'` то и `A' => B'`

Можно сказать данное исчисление моделирует паралельные системы как набор потоков, которые передают друг другу данные пользуясь некоторым каналом передачи данных. 

Можно сделать гибрид лямбда исчисления и пи исчисления используя такие конструкции:
1. Переменная `x`, `y` и тд. 
2. "Абстракция", или функция/лямбда `fn x -> body`. Функции всегда объявляют одну переменную, которую можно использовать в теле функции. Тело функции распространяется максимально вправо, и ограничено лишь круглыми скобками. 
3. "Применение абстракции" или вызов функции, обозначаются двумя переменными подряд `x y`. Вызов функций лево-асоциативный, что значит `x y z = (x y) z` 
4.  "Канал" - `ch`. "Создает" уникальный канал для передачи данных между двумя паралельными процессами.
5. "Получение данных" - `x.receive fn y -> body`. Ожидает данных из канала `x`, которые отправит продюсер и вызивает переданную лямбду с полученными данными.
6. "Отправка данных" - `x.send y rest`. Ждет пока получатель примет данные через канал `x`, и вернет `rest`.
7. "Одновременное выполнение" - `x | y`. Выполняет `х` и `у` "одновременно".
6. "Нулевой процесс" - `void`. Процесс который уже закончился.

Правила редукции тогда таковы:
1. `(fn x -> A) y => A[x=y]`
2. `fn x -> f x => f`
3. `... | (сh#n.send A B) | (сh#n.send C D) | (сh#n.receive fn x -> E) => ... | B | D | E[x=(... | A | C)]`, если ниодно другое правило не применимо нигде в виражении
4. `A | void => A`
5. `A | B => A | C` если `B => C`
6. `A (B | C) => (A B) | (A C)`
7.  `(A | B) C => (A C) | (B C)`
8.  `(fn x -> A) ch => A[x=ch#n]`, где `n` это порядковый номер появления канала в изначальном выражении
9.  `fn x -> (A | B) => A | fn x -> B` если `x` не используется в `A`

Примеры таких выражений и их редукций:
1. `(fn x -> (x.receive fn y -> y 2) | (x.send (fn z -> z + 1) 0)) ch`
    `(ch#0.receive fn y -> y 2) | (ch#0.send (fn z -> z + 1) 0)`
    `((fn z -> z + 1) 2) | (0)`
    `(fn z -> z + 1) 2)`
    `2 + 1`
    `3`
2. `(fn x -> (x.receive fn y -> x.send (y 2) ((y 3) * 2)) | (x.send (fn z -> z + 1) (x.receive fn x -> x * 2))) ch`
`(ch#0.receive fn y -> ch#0.send (y 2) ((y 3) * 4)) | (ch#0.send (fn z -> z + 1) (ch#0.receive fn x -> x * 2))`
`ch#0.send ((fn z -> z + 1) 2) (((fn z -> z + 1) 3) * 4) | ch#0.receive fn x -> x * 2`
`(((fn z -> z + 1) 3) * 4) | ((fn z -> z + 1) 2) * 2`
`(3 + 1) * 4 | (2 + 1) * 2`
`4 * 4 | 3 * 2`
`16 | 6`

3. `(fn w -> w * w) ((fn x -> (x.receive fn y -> x.send (y 2) ((y 3) * 2)) | (x.send (fn z -> z + 1) (x.receive fn x -> x * 2))) ch)`
`(fn w -> w * w) (16 | 6)`
`((fn w -> w * w) 16) | ((fn w -> w * w) 6)`
`16 * 16 | 6 * 6`
`256 | 36`

Редукции между паралельными частями могут выполняться в любом порядке, до тех пор пока ниодна из них не может быть упрощена без использования правила 3 (передачи данных по каналу). Как только такая точка была достигнута, можно использовать правило 3, если это возможно.
На самом деле такое ограничение исходит из аксиомы асоциативности паралельных процессов, тк иначе мы можем выбирать когда и какой поток получит данные, а какой нет, что может привести к разным результатам.
Таким образом комуникации между потоками являются точками синхронизации, тк перед тем что бы мы могли продолжить упрощать то что будет дальше, нам нужно дождаться что бы все потоки или ждали или отправляли данные через канал.

Данный механизм может позволить например реализовать класический async\await без разукрашивания функций, как это в JS или Rust:

Пример работы такого асинк авейта:
```
{
  f = async fn x -> x + 1
  g = fn x -> x * 2

  x = f 2
  y = async g 3
  z = 3 + 1

  z + await y + await x
}
=> 
{
  f = fn x -> x + 1
  g = fn x -> x * 2

  | ch#0.send (f 2) void 
  | ch#0.receive fn x -> {
    y = async g 3
    z = 3 + 1

    z + await y + x
  }
}
=> 
{
  f = fn x -> x + 1
  g = fn x -> x * 2
  
  | ch#0.send (f 2) void 
  | ch#0.receive fn x -> 
    | ch#1.send (g 3) void 
    | ch#1.receive fn y -> {
      z = 3 + 1
      z + y + x
    }
}
=> 
{
  f = async fn x -> x + 1
  g = fn x -> x * 2
  
  | ch#0.send (f 2) void 
  | ch#1.send (g 3) void 
  | ch#0.receive fn x -> 
    | ch#1.receive fn y -> {
      z = 3 + 1
      z + y + x
    }
}

```

```
{
  f = async fn x -> x + 1
  x = f 2
  y = 3 + 1
  z = async fn w -> w * await x

  y + await (z 2)
}
```

  
[Pi-calculus](https://en.wikipedia.org/wiki/%CE%A0-calculus)